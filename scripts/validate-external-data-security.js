#!/usr/bin/env node\n\n/**\n * External Data Security Validation Script\n * \n * Validates that the external data premium gating system is working correctly\n * in both staging and production environments\n * \n * @author Gil Klainert\n * @created 2025-08-25\n * @version 1.0\n */\n\nconst admin = require('firebase-admin');\nconst { getFunctions, httpsCallable } = require('firebase/functions');\nconst { initializeApp } = require('firebase/app');\n\n// Configuration\nconst ENVIRONMENTS = {\n  staging: {\n    projectId: 'getmycv-ai-staging',\n    region: 'us-central1'\n  },\n  production: {\n    projectId: 'getmycv-ai',\n    region: 'us-central1'\n  }\n};\n\nclass ExternalDataSecurityValidator {\n  constructor(environment = 'staging') {\n    this.environment = environment;\n    this.config = ENVIRONMENTS[environment];\n    \n    if (!this.config) {\n      throw new Error(`Invalid environment: ${environment}`);\n    }\n    \n    console.log(`\\nüîç Validating External Data Security - ${environment.toUpperCase()} Environment`);\n    console.log('=' .repeat(70));\n  }\n\n  async initialize() {\n    try {\n      // Initialize Firebase Admin\n      if (!admin.apps.length) {\n        admin.initializeApp({\n          projectId: this.config.projectId\n        });\n      }\n      \n      // Initialize Firebase App for client functions\n      this.app = initializeApp({\n        projectId: this.config.projectId\n      });\n      \n      this.functions = getFunctions(this.app, this.config.region);\n      this.db = admin.firestore();\n      \n      console.log('‚úÖ Firebase initialized successfully\\n');\n      \n    } catch (error) {\n      console.error('‚ùå Failed to initialize Firebase:', error.message);\n      throw error;\n    }\n  }\n\n  async validatePremiumGating() {\n    console.log('üîí Testing Premium Access Gating...');\n    \n    try {\n      // Test 1: Call enrichCVWithExternalData without premium access\n      const enrichFunction = httpsCallable(this.functions, 'enrichCVWithExternalData');\n      \n      try {\n        await enrichFunction({\n          cvId: 'test-cv-123',\n          sources: ['github'],\n          options: { timeout: 10000 }\n        });\n        \n        console.log('‚ùå SECURITY ISSUE: Function should have blocked non-premium access');\n        return false;\n        \n      } catch (error) {\n        if (error.code === 'permission-denied' && error.message.includes('premium')) {\n          console.log('‚úÖ Premium gating working correctly - blocked non-premium access');\n        } else {\n          console.log(`‚ö†Ô∏è  Unexpected error: ${error.message}`);\n        }\n      }\n      \n      return true;\n      \n    } catch (error) {\n      console.error('‚ùå Premium gating validation failed:', error.message);\n      return false;\n    }\n  }\n\n  async validateUsageTracking() {\n    console.log('\\nüìä Testing Usage Tracking...');\n    \n    try {\n      // Check if usage tracking collections exist\n      const usageCollection = this.db.collection('external_data_usage');\n      const analyticsCollection = this.db.collection('external_data_analytics');\n      \n      // Test collections are accessible (they may be empty)\n      const usageSnapshot = await usageCollection.limit(1).get();\n      const analyticsSnapshot = await analyticsCollection.limit(1).get();\n      \n      console.log('‚úÖ Usage tracking collections accessible');\n      console.log(`   - Usage events collection: ${usageSnapshot.size} sample records`);\n      console.log(`   - Analytics collection: ${analyticsSnapshot.size} sample records`);\n      \n      return true;\n      \n    } catch (error) {\n      console.error('‚ùå Usage tracking validation failed:', error.message);\n      return false;\n    }\n  }\n\n  async validateSecurityAuditLogging() {\n    console.log('\\nüîç Testing Security Audit Logging...');\n    \n    try {\n      // Check if security audit collection exists\n      const auditCollection = this.db.collection('external_data_security_audit');\n      const auditSnapshot = await auditCollection.limit(1).get();\n      \n      console.log('‚úÖ Security audit collection accessible');\n      console.log(`   - Audit events: ${auditSnapshot.size} sample records`);\n      \n      return true;\n      \n    } catch (error) {\n      console.error('‚ùå Security audit validation failed:', error.message);\n      return false;\n    }\n  }\n\n  async validateRateLimiting() {\n    console.log('\\n‚è±Ô∏è  Testing Rate Limiting (Basic Check)...');\n    \n    try {\n      // This is a basic check - in production you'd want more sophisticated testing\n      const policyDoc = await this.db.collection('policy_config').doc('rate_limits').get();\n      \n      if (policyDoc.exists) {\n        const rateLimits = policyDoc.data();\n        console.log('‚úÖ Rate limiting configuration found');\n        console.log(`   - Configuration: ${JSON.stringify(rateLimits, null, 2)}`);\n      } else {\n        console.log('‚ö†Ô∏è  Rate limiting configuration not found (may be hardcoded)');\n      }\n      \n      return true;\n      \n    } catch (error) {\n      console.error('‚ùå Rate limiting validation failed:', error.message);\n      return false;\n    }\n  }\n\n  async validateAnalyticsFunctions() {\n    console.log('\\nüìà Testing Analytics Functions...');\n    \n    try {\n      // Test analytics functions are deployed\n      const functions = [\n        'getExternalDataAnalytics',\n        'getDailyExternalDataAnalytics',\n        'getConversionMetrics',\n        'trackConversionEvent'\n      ];\n      \n      let functionsWorking = 0;\n      \n      for (const functionName of functions) {\n        try {\n          const testFunction = httpsCallable(this.functions, functionName);\n          \n          // Try calling with minimal test data\n          await testFunction({ adminAccess: false });\n          \n          console.log(`‚úÖ ${functionName} - deployed and callable`);\n          functionsWorking++;\n          \n        } catch (error) {\n          if (error.code === 'permission-denied') {\n            console.log(`‚úÖ ${functionName} - deployed with proper auth`);\n            functionsWorking++;\n          } else {\n            console.log(`‚ö†Ô∏è  ${functionName} - ${error.message}`);\n          }\n        }\n      }\n      \n      console.log(`\\n   Summary: ${functionsWorking}/${functions.length} analytics functions working`);\n      return functionsWorking === functions.length;\n      \n    } catch (error) {\n      console.error('‚ùå Analytics functions validation failed:', error.message);\n      return false;\n    }\n  }\n\n  async validateDatabaseIndexes() {\n    console.log('\\nüóÇÔ∏è  Checking Database Indexes...');\n    \n    try {\n      // Check if required indexes exist by testing queries that would fail without them\n      const testQueries = [\n        {\n          collection: 'external_data_usage',\n          query: (ref) => ref.where('timestamp', '>=', new Date(Date.now() - 86400000)).limit(1)\n        },\n        {\n          collection: 'external_data_security_audit',\n          query: (ref) => ref.where('timestamp', '>=', new Date(Date.now() - 86400000)).limit(1)\n        }\n      ];\n      \n      let indexesWorking = 0;\n      \n      for (const { collection, query } of testQueries) {\n        try {\n          const collectionRef = this.db.collection(collection);\n          await query(collectionRef).get();\n          console.log(`‚úÖ ${collection} - indexes working`);\n          indexesWorking++;\n        } catch (error) {\n          console.log(`‚ö†Ô∏è  ${collection} - may need indexes: ${error.message}`);\n        }\n      }\n      \n      console.log(`\\n   Summary: ${indexesWorking}/${testQueries.length} index checks passed`);\n      return indexesWorking > 0; // At least some indexes working\n      \n    } catch (error) {\n      console.error('‚ùå Database indexes validation failed:', error.message);\n      return false;\n    }\n  }\n\n  async runValidation() {\n    console.log(`Starting validation at ${new Date().toISOString()}\\n`);\n    \n    const results = {\n      premiumGating: false,\n      usageTracking: false,\n      securityAudit: false,\n      rateLimiting: false,\n      analyticsFunctions: false,\n      databaseIndexes: false\n    };\n    \n    try {\n      results.premiumGating = await this.validatePremiumGating();\n      results.usageTracking = await this.validateUsageTracking();\n      results.securityAudit = await this.validateSecurityAuditLogging();\n      results.rateLimiting = await this.validateRateLimiting();\n      results.analyticsFunctions = await this.validateAnalyticsFunctions();\n      results.databaseIndexes = await this.validateDatabaseIndexes();\n      \n    } catch (error) {\n      console.error('\\n‚ùå Validation process failed:', error.message);\n    }\n    \n    // Generate report\n    console.log('\\n' + '='.repeat(70));\n    console.log('üìã VALIDATION REPORT');\n    console.log('='.repeat(70));\n    \n    const passed = Object.values(results).filter(r => r).length;\n    const total = Object.keys(results).length;\n    \n    Object.entries(results).forEach(([test, passed]) => {\n      const status = passed ? '‚úÖ PASS' : '‚ùå FAIL';\n      const testName = test.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());\n      console.log(`${status} - ${testName}`);\n    });\n    \n    console.log('\\n' + '='.repeat(70));\n    console.log(`OVERALL RESULT: ${passed}/${total} tests passed`);\n    \n    if (passed === total) {\n      console.log('üéâ All validation tests PASSED! System is ready for production.');\n    } else if (passed >= total * 0.8) {\n      console.log('‚ö†Ô∏è  Most tests passed. Review failed tests before production deployment.');\n    } else {\n      console.log('‚ùå Multiple tests failed. System NOT ready for production.');\n    }\n    \n    console.log('='.repeat(70));\n    \n    return { passed, total, results };\n  }\n}\n\n// CLI execution\nif (require.main === module) {\n  const environment = process.argv[2] || 'staging';\n  \n  async function main() {\n    const validator = new ExternalDataSecurityValidator(environment);\n    \n    try {\n      await validator.initialize();\n      const report = await validator.runValidation();\n      \n      // Exit with appropriate code\n      process.exit(report.passed === report.total ? 0 : 1);\n      \n    } catch (error) {\n      console.error('\\nüí• Validation script failed:', error.message);\n      process.exit(2);\n    }\n  }\n  \n  main();\n}\n\nmodule.exports = ExternalDataSecurityValidator;"